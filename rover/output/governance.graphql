schema @link(url: "https://specs.apollo.dev/federation/v2.7", import: ["@tag"]) {
  query: Query
  mutation: Mutation
}

"""Date with time (isoformat)"""
scalar DateTime

type DjangoModelType {
  pk: ID!
}

"\n     Errors messages and codes mapped to\n    fields or non fields errors.\n    Example:\n    {\n        field_name: [\n            {\n                \"message\": \"error message\",\n                \"code\": \"error_code\"\n            }\n        ],\n        other_field: [\n            {\n                \"message\": \"error message\",\n                \"code\": \"error_code\"\n            }\n        ],\n        nonFieldErrors: [\n            {\n                \"message\": \"error message\",\n                \"code\": \"error_code\"\n            }\n        ]\n    }\n    "
scalar ExpectedError

type Mutation {
  "### Checks if a token is not expired and correct.\n\n*Note that this is not for refresh tokens.*\n"
  verifyToken(token: String!): VerifyTokenType!

  "Update user model fields, defined on settings.\n\nUser must be verified.\n"
  updateAccount(lastName: String, firstName: String): MutationNormalOutput!

  "Archive account and revoke refresh tokens.\n\nUser must be verified and confirm password.\n"
  archiveAccount(password: String!): MutationNormalOutput!

  "Delete account permanently or make `user.is_active=False`.\n\nThe behavior is defined on settings. Anyway user refresh tokens are\nrevoked.\n\nUser must be verified and confirm password.\n"
  deleteAccount(password: String!): MutationNormalOutput!

  "Change account password when user knows the old password.\n\nA new token and refresh token are sent. User must be verified.\n"
  passwordChange(newPassword2: String!, oldPassword: String!, newPassword1: String!): ObtainJSONWebTokenType!
  tokenAuth(username: String!, password: String!): ObtainJSONWebTokenType! @tag(name: "public")
  refreshToken(refreshToken: String!, revokeRefreshToken: Boolean!): ObtainJSONWebTokenType! @tag(name: "public")

  "Register user with fields defined in the settings. If the email field of\nthe user model is part of the registration fields (default), check if there\nis no user with that email.\n\nIf it exists, it does not register the user, even if the email field\nis not defined as unique (default of the default django user model).\n\nWhen creating the user, it also creates a `UserStatus` related to\nthat user, making it possible to track if the user is archived /\nverified.\n\nSend account verification email.\n\nIf allowed to not verified users login, return token.\n"
  register(username: String!, password1: String!, email: String!, password2: String!): MutationNormalOutput!

  "Verify user account.\n\nReceive the token that was sent by email. If the token is valid,\nmake the user verified by making the `user.status.verified` field\ntrue.\n"
  verifyAccount(token: String!): MutationNormalOutput!

  "Sends activation email.\n\nIt is called resend because theoretically the first activation email\nwas sent when the user registered.\n\nIf there is no user with the requested email, a successful response\nis returned.\n"
  resendActivationEmail(email: String!): MutationNormalOutput!

  "Send password reset email.\n\nFor non verified users, send an activation email instead.\n\nIf there is no user with the requested email, a successful response\nis returned.\n"
  sendPasswordResetEmail(email: String!): MutationNormalOutput!

  "Change user password without old password.\n\nReceive the token that was sent by email.\n\nIf token and new passwords are valid, update user password and in\ncase of using refresh tokens, revoke all of them.\n\nAlso, if user has not been verified yet, verify it.\n"
  passwordReset(token: String!, newPassword2: String!, newPassword1: String!): MutationNormalOutput!

  "\nSet user password - for password-less registration\n\nReceive the token that was sent by email.\n\nIf token and new passwords are valid, set\nuser password and in case of using refresh\ntokens, revoke all of them.\n\nAlso, if user has not been verified yet, verify it.\n"
  passwordSet(token: String!, newPassword2: String!, newPassword1: String!): MutationNormalOutput!

  "### Suspends a refresh token.\n\n*token must exist to be revoked.*\n"
  revokeToken(refreshToken: String!): RevokeRefreshTokenType!
}

type MutationNormalOutput {
  success: Boolean!
  errors: ExpectedError
}

"\n    encapsulates token data, and refresh token data if `JWT_LONG_RUNNING_REFRESH_TOKEN` is on.\n    with an output interface.\n    "
type ObtainJSONWebTokenType implements OutputInterface {
  success: Boolean!
  errors: ExpectedError
  user: UserType
  token: TokenType
  refreshToken: RefreshTokenType
}

interface OutputInterface {
  success: Boolean!
  errors: ExpectedError
}

type Query {
  _service: _Service!
  me: UserType!

  """Returns the current user if he is not anonymous."""
  public: UserType
  allTenants: [TenantType!]!
  getTenant(id: Int!): TenantType
}

"\nRefresh token can be used to obtain a new token instead of log in again\nwhen the token expires.\n\n*This is only used if `JWT_LONG_RUNNING_REFRESH_TOKEN` is set to True.*\n"
type RefreshTokenType {
  """randomly generated token that is attached to a FK user."""
  token: String!
  created: DateTime!
  revoked: DateTime
  expiresAt: DateTime!
  isExpired: Boolean!
}

type RevokeRefreshTokenType {
  success: Boolean!
  refreshToken: RefreshTokenType
  errors: ExpectedError
}

type TenantType {
  id: ID!
  name: String!
}

"\nthe data that was used to create the token.\n"
type TokenPayloadType {
  """when the token was created"""
  origIat: DateTime!

  """when the token will be expired"""
  exp: DateTime!
  username: String!
}

"\nencapsulates the token with the payload that was used to create the token.\n"
type TokenType {
  payload: TokenPayloadType!

  """The encoded payload, namely a token."""
  token: String!
}

type UserStatusType {
  verified: Boolean!
  archived: Boolean!
}

type UserType {
  logentrySet: [DjangoModelType!]!
  isSuperuser: Boolean!
  lastLogin: DateTime
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  status: UserStatusType!
  lastName: String
  id: ID!
  firstName: String
  username: String!
  email: String!
  archived: Boolean!
  verified: Boolean!
}

type VerifyTokenType implements OutputInterface {
  success: Boolean!
  errors: ExpectedError
  token: TokenType
  user: UserType
}

scalar _Any

type _Service {
  sdl: String!
}
